import pandas as pd
import os
from sklearn.preprocessing import MinMaxScaler

def multi_sensor_ssc_integration(l5_dfpath='', l7_dfpath='', l8_dfpath='', l9_dfpath='', s2_dfpath=''):
    """
    Integrates Suspended Sediment Concentration (SSC) data from multiple satellite sources into a single DataFrame.

    This function reads SSC data from CSV files generated by different satellite sensors (Landsat 5, 7, 8, 9, and Sentinel-2),
    merges the data into a unified DataFrame, and sorts it by date. Each row in the resulting DataFrame contains the SSC
    values from one of the sensors, and an additional column indicates the satellite source. Only unique dates are retained,
    with the first occurrence kept in cases of duplicates.

    Parameters:
    ----------
    l5_dfpath : str, optional
        Path to the CSV file for Landsat 5 data. Default is an empty string.
    l7_dfpath : str, optional
        Path to the CSV file for Landsat 7 data. Default is an empty string.
    l8_dfpath : str, optional
        Path to the CSV file for Landsat 8 data. Default is an empty string.
    l9_dfpath : str, optional
        Path to the CSV file for Landsat 9 data. Default is an empty string.
    s2_dfpath : str, optional
        Path to the CSV file for Sentinel-2 data. Default is an empty string.

    Returns:
    -------
    pd.DataFrame
        A DataFrame containing the combined SSC proxy ratios from the specified satellite sources.
        Columns:
        - date: The date of the SSC measurement.
        - water_red_sum: Sum of red band reflectance values over water pixels.
        - water_green_sum: Sum of green band reflectance values over water pixels.
        - water_nir_sum: Sum of NIR band reflectance values over water pixels.
        - water_red_green_mean: Mean of red/green ratio over water pixels.
        - water_nir_red_mean: Mean of NIR/red ratio over water pixels.
        - sat: The satellite source for each row (l5, l7, l8, l9, or s2).

    Raises:
    ------
    ValueError
        If none of the specified file paths exist or are provided.

    Notes:
    ------
    - At least one valid file path must be provided for the function to execute successfully.

    Example Usage:
    --------------
    >>> l5_path = 'path/to/l5_data.csv'
    >>> l7_path = 'path/to/l7_data.csv'
    >>> s2_path = 'path/to/s2_data.csv'
    >>> merged_ssc_df = multi_sensor_ssc_integration(l5_dfpath=l5_path, l7_dfpath=l7_path, s2_dfpath=s2_path)
    >>> print(merged_ssc_df.head())
    """
    
    # Check that at least one valid file path is provided
    if not any([os.path.isfile(p) for p in [l5_dfpath, l7_dfpath, l8_dfpath, l9_dfpath, s2_dfpath]]):
        raise ValueError("At least one valid file path must be provided.")

    # Define a list to store DataFrames
    dfs = []

    # Load and process each file if it exists
    for path, satellite in zip(
        [l5_dfpath, l7_dfpath, l8_dfpath, l9_dfpath, s2_dfpath],
        ['l5', 'l7', 'l8', 'l9', 's2']
    ):
        if os.path.isfile(path):  # Check if file exists
            df = pd.read_csv(path)
            # Rename date column for consistency
            if satellite == 's2':
                df = df.rename(columns={'date': 'mosaic_enddate'})
            df['date'] = pd.to_datetime(df['mosaic_enddate'])
            df['sat'] = satellite  # Add satellite column
            # Select only relevant columns
            df = df[['date', 'water_red_sum', 'water_green_sum', 'water_nir_sum', 'water_red_green_mean', 'water_nir_red_mean', 'sat']]
            dfs.append(df)

    # Concatenate all DataFrames
    merged_df = pd.concat(dfs, ignore_index=True)
    
    # Sort by date and drop duplicates keeping the first occurrence
    merged_df = merged_df.sort_values(by='date').drop_duplicates(subset='date', keep='first').reset_index(drop=True)

    return merged_df

def normalize_ssc(df):
    """
    Creates Normalized Suspended Sediment Concentration (NSSC) values in a DataFrame using ratio of reflectance values.
    
    This function adds four new columns to the DataFrame by normalizing pixel-level and reservoir-level 
    SSC estimates. Pixel-level SSC ratios are normalized directly from `water_red_green_mean` and 
    `water_nir_red_mean`. Reservoir-level SSC ratios are calculated by dividing sum columns 
    (`water_red_sum`, `water_green_sum`, `water_nir_sum`) and then normalized.

    Parameters:
    ----------
    df : pd.DataFrame
        The DataFrame containing SSC data, with columns:
        - water_red_sum
        - water_green_sum
        - water_nir_sum
        - water_red_green_mean
        - water_nir_red_mean

    Returns:
    -------
    pd.DataFrame
        The original DataFrame with the following new columns added:
        - nssc_rd_gn_px: Normalized pixel-level SSC ratio (red/green).
        - nssc_nr_rd_px: Normalized pixel-level SSC ratio (nir/red).
        - nssc_rd_gn_res: Normalized reservoir-level SSC ratio (red/green).
        - nssc_nr_rd_res: Normalized reservoir-level SSC ratio (nir/red).
    """
    
    # Initialize scaler
    scaler = MinMaxScaler()

    ## Normalize pixel-level SSC ratios, ignoring NaNs
    if df['water_red_green_mean'].notna().any():
        non_na_data = df['water_red_green_mean'].dropna().values.reshape(-1, 1)
        df.loc[df['water_red_green_mean'].notna(), 'nssc_rd_gn_px'] = scaler.fit_transform(non_na_data).flatten()
    
    if df['water_nir_red_mean'].notna().any():
        non_na_data = df['water_nir_red_mean'].dropna().values.reshape(-1, 1)
        df.loc[df['water_nir_red_mean'].notna(), 'nssc_nr_rd_px'] = scaler.fit_transform(non_na_data).flatten()
    
    # Calculate reservoir-level SSC ratios and normalize, ignoring NaNs
    valid_ratio_rd_gn = (df['water_red_sum'] / df['water_green_sum']).dropna()
    if valid_ratio_rd_gn.any():
        scaled_data = scaler.fit_transform(valid_ratio_rd_gn.values.reshape(-1, 1)).flatten()
        df.loc[valid_ratio_rd_gn.index, 'nssc_rd_gn_res'] = scaled_data
    
    valid_ratio_nr_rd = (df['water_nir_sum'] / df['water_red_sum']).dropna()
    if valid_ratio_nr_rd.any():
        scaled_data = scaler.fit_transform(valid_ratio_nr_rd.values.reshape(-1, 1)).flatten()
        df.loc[valid_ratio_nr_rd.index, 'nssc_nr_rd_res'] = scaled_data
    
    return df